// 自增和自减运算符(前缀，后缀),需要注意以下几点
1. ++x与x++的区别
```cpp
int x=1;
int a = x++;
std::cout<<x<<endl; // 2,x++还是使用x的原值，表达式过后x才加一
std::cout<<a<<endl; // 1
int y=1;
int b = ++y;
std::cout<<y<<endl; // 2，++y使用y加一后的值
std::cout<<b<<endl; // 2
```

2. 自增自减何时生效
```cpp
// 顺序点，所有赋值或者自增自减都要在另一个顺序点开始之前完成所有的修改。所以无论自增还是自减在经过顺序点之后肯定已经完成了自加，以下示例了几种常见属于顺序点的情况。除此之外大部分都不是顺序点。
int x,y=12; // 分号、逗号，都属于顺序点
while (x++>10)
    cout x; // 13 ,完整的表达式属于顺序点，x++>10作为一个测试表达式，已经是一个完整的表达式。
bool b;
x++ < 0 && x > 12;
x++ < 0 || x > 12;
// 逻辑运算符中的与&&和或||是顺序点
```

3. 如果没有使用到表达式的值，那么前缀和后缀是无差别的,如下例
```cpp
for(int x;x<10;x++)
    ......;

for(int x;x<10;++x)
    ......;
// 两者等效
```


4. 对类而言，前++会比后++效率更高，因为后缀会复制一个副本，然后加一，将副本返回。

5. 指针的自增自减符号顺序
```cpp
// 总共就三种情况*ptr++,*++ptr,++*ptr都遵循从右到左原则
int arr[5]={1,4,6,8,9};
int *ptr=arr;
cout<<*ptr++; // 1
cout<<*++ptr; // 4
cout<<++*ptr; // 2
```

6. 不要即读又修改
```cpp
int x=5;
bool b=(x==x++); // 因为==不是顺序点，所以这里明确的顺序，是先读还是先改x,会造成不确定结果,禁止使用这种写法。
```