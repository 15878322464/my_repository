// 运算符
// 1.不同数据类型做运算，数据类型小的会被隐式转换为大的数据类型，然后才运算，同一个运算符，不同的数据类型也有不同的运算函数，运算符的重载。   
// 2.强制类型转换“typeName（vale）”,不会修改vale变量本身，而是新建一个。  
// 3.每个表达式都有值，例如
```cpp
int a;
std::cout<<(a=3); //输出3
```
// 4.<，>这些运算符不能直接想数学表达式一样拼接着使用，要用&&与连接
```cpp
3<x<2 // 这个表达式会被编译成（3<x）<2,而（3<x）的值是bool类型。
3<x && x<2; //正确用法
```

// 5.c++运算符都是从左到右，得到答案后立刻停止，例如逻辑与，只要前一个为假，则直接为假，不再判断下一个。

// 6.运算符重载
```cpp
// 返回值类型 operator运算符(){};
// 成员函数的重载运算符
class op{
private:
    int i;
public:
   op operator+(const op &p) const; // 如果没有对类数据进行修改，只是读取，记得用const，适用性更广，安全性更高
  op operator++();
}
void op::operator+(const op &p) {
  op square;
  square=op(i+p.i); // 返还的是自身类对象时可以使用构造函数
  return square; // 结果名称尽量能表达该函数的作用，可视为函数名来命名。
}
op& op::operator++(){
  ++i;
  return *this;
}

// 非成员函数的多元重载运算符，形参必须有一个是用户自定的类型（类、结构体或者枚举),这是为了防止用户将标准类型重载运算符，例如不能让用户将两个int的“-”重载成他们的和，这会乱套。非成员函数一般没有权限访问到类数据，所以一般都搭配使用友元函数，这样才能访问私有数据
op operator*(const op &p) {
  op square;
  result.o = p.o * o;
  return square; // 如果返还的是一个新的类对象，那可以优先考虑用构造函数op(square)，更能保证正确性。
}

// 运算符重载的调用及底层原理
int main() {
  op p1, p2, p3，p4;
  p3 = p1 * p2; // 运算符表示法
  p3 = p1.operator*(p2); // 识别到*左右两边是op对象后，则替换为函数调用，左操作数是调用对象，右操作数是被传参数，顺序不要搞错
  p4 = p1*p2*p3; // 这也是可以的，这相当于p1.operator(p2.operator(p3))
}
```
(1)不能创建新的运算符进行重载  
(2)不能违反原来的运算符规则  
(3)不能修改运算符的优先级  
(4)不能重载以下运算符：
(5)能重载的运算符：
(6)只能用成员函数重载的运算符：
(7)成员函数和非成员函数版本并没有太大区别，只不过某些操作符只能用非成员函数的版本，但对于为类定义类型转换时用非成员函数版本会更好。
(8)无参数的重载函数都是重载一元运算符的（有几个操作数就是几元，像-x就是减号的一元版本，a-x就是减号的二元版本，不是所有运算符都有一元版本，例如除运算符）

// << 插入运算符

// 标记：一行代码中，不可分割的元素叫做标记，空白：空格、制表符、回车，标记必须用空白分开

// 赋值运算符