// 数据类型

2. 数据类型转换
```cpp
// 隐式转换（能不能隐式转换要看什么情况）
    // 会发生隐式转换的情况罗列

    // 1.初始化和赋值时（都能转换）
    double b = 1.99888282737;
    int c = 1.9999;
    b = c;

    // 2.{}列表初始化时，（其隐式转换更加严格）
    long l{2147483647};
    const long l1{2147483647}; 
    // int c = {l}; 不允许，l是变量，编译器对其大小未知。
    int c1 = {l1}; // 不同整型之间可以相互转换，但是要装的下(也就是不能缩窄)，还要是已知量,不同浮点型也是如此，但是在{}初始化时浮点不能隐式转换为整型

    // 3.表达式中的转换
    short s1=1;
    short s2=2;
    auto i=s1+s2;
    cout << typeid(i).name() << endl; // i,所有小于int的整数类型在计算表达式时都会自动转换为int后再计算，叫做整型提升（算数类型相同也是如此），在算数类型不同的情况下则是小的转换为大的,级别相同(大小相同类型不同)则是无符号>有符号，在传统c语言中还会存在将float转换为double，包括类型相同时。

    // 传递参数时的转换
    void printt(int i);

    // void printt(float f); // 函数重载则取消了原型对函数参数传递的控制，不再像赋值时那样的标准转换而是变成了像用{}初始化时的要求，不允许缩窄转换。
    int main() {
    printt(1.089);
    }
// 显式转换(强制转换)
(typeName)value; // c写法
typeName(value); // c++写法，更像是函数调用
    // 还有四个强制类型转换运算符
```
(1)隐式转换顺序为，最佳匹配>完全匹配，小转大>大转小，无符号>有符号