// 类,由结构体演变而来,与结构体完全相同，唯一不同就是结构体默认权限是public，类的默认权限是private
```cpp
class base{
private:
    int i;
    float f;
public:
    void printt();
    void printt2() const; // 常量成员函数，该函数内，不允许修改类数据,注意，常量成员函数即可以被常量对象调用，也可以被非常量对象，常量对象只能调用常量成员函数，因为普通成员函数不能保证不修改对象的数据。所以在该函数不修改类数据的情况下推荐把他声明为常量函数，这样不管是常量还是非常量对象都能调用。
};
```

// 1.类权限,这里的使用权限一般有三种情况，类内部（类成员函数）、类外部（类对象）、派生类，这三种情况是否可以使用。下面也是针对这三种情况来描述权限
```cpp
// 不加关键词默认为private权限
class base{
// 私有权限，只能在类内部使用（外部想使用可以通过公有成员函数或者友元函数去修改或访问），数据成员都用该用private进行保护，提供对应的增删改查接口就行，确保数据安全。
private:
    int pri;
    void function();
// 公开权限，无论是类内部还是类对象都能使用，一般用于需要暴露在外供他人使用的成员函数接口
public:
    int pub;
    void function();
// 保护权限，再没有继承时，与私有属性一样，一般修饰专门给派生类用的成员函数。注意，只有在派生类的成员函数中才能使用，即使是派生类对象也无法调用基类的protected成员，
protected:
    int pro;
    void function();
};

```

// 2. 类的成员函数，可在类内类外定义（类内定义会被解释为内联函数，所以只有体量非常小时才直接在内定义）
```cpp

```

// 3.继承
```cpp
// (1)三种继承方式,不加关键词默认是private继承，不管何种继承，基类的private都不可使用。
/* 类与类之间不止是继承关系:
1.is-a关系，也就是继承关系：谁是谁，例如香蕉是水果，一般是用公有继承实现，因为香蕉具备水果所有的属性，它应该能够直接使用跟修改所有水果基类的数据；
2.has-a关系：谁有谁，例如午餐里有水果，米饭，这种一般就是用午餐类包含水果类和米饭类来实现,可使用私有多重继承或者保护多重继承；
3.is-like-a：谁像谁，这种关系通常都是两者有共同点，但是也都有不同点，这时候就可以用抽象基类把他们的共同点提取出来然后再各自继承这个抽象基类；
4.is-implemented-a:使用什么来实现什么，例如使用数组来实现栈，这种关系可以让栈包含一个私有数组对象来实现
5.uses-a：谁可以用谁，或者谁能操控谁，例如计算机可以用打印机，遥控器可以控制空调，这两种类不具备啥直接关系，但是他们两者有通信，这种关系可以用友元函数或者友元类来实现。
总结：不要乱用继承，只有is-a关系才能用继承，其他关系强行用继承会导致诸多编程问题。
*/

// 公有继承，派生类内部可访问基类中的public、protected,并且保持原来的属性。也就是derive对象能调pub，公有继承一般用来建立is-a关系
class derive:public base{
    string str;
};

// 保护继承，protected是在唯一一个在继承中才能体现出来的
class derive:protected base{
    string str;
};

// 私有继承，派生类内部可访问基类中的public、protected,但在该派生类中，两者全部变为private，也就是此时的derive对象无法调用pub,并且其derive的派生类内部无法使用pub和pro,因为已经在derive阶段变成了private，私有继承一般用于建立has-a关系，详情见第20点
class derive:private base{
    string str;
};
(1)没有继承任何类的类，未修饰的成员默认为private,如果是子类则默认权限是对应的继承方式。

// (2)派生类的构造函数
Derive::Derive(基类初始化所需的相关参数，string s):Base(基类初始化所需的相关参数),str(s){} // 派生类需要自己的构造函数，必须给新成员(如果有)以及基类成员提供数据,但私有数据不能访问所以用初始化列表调用基类构造函数。


// (3)基类引用与基类指针可以指向派生类对象,但是其只能调用基类方法，也只是单向的，不能将派生类的指针或引用指向基类，一般用于将基类引用或指针用于函数参数，这样就能即接收基类参数又能接收派生类参数。
derive der;
base &ba=der;
base *ba=&der;
base ba2(der); // 可以接收，派生类中的基类数据将赋值到ba2

// (4)什么才是真正的继承关系？（不是继承关系的不要乱用继承）
    // is-a关系才是真正的继承关系，香蕉是一种水果（The banana is a type of fruit）,A是B,这样能说得通的才是继承关系，A继承B
    // 用A实现B(is-implemented-as-a)、A像B(is-like-a)、A包括B也叫组合、包含(has-a)，A使用B(users-a)这些都不属于继承关系，不能用继承来表示。包含的时候，成员列表初始化要用成员变量名，而不是像继承那样使用基类的类型名名base()

// (5)虚函数(可以让通过对象引用或指针调用成员方法时，使用对象类型定义的方法也就是派生类自己修改实现的方法，而不是本身指针或引用类型的方法，也就是基类方法。)
class  base{
public:
    virtual void printt(); // virtual一般在原型声明上加上就行了
    virtual ~base(); // 为基类声明一个虚析构函数，可以确保释放派生对象时，按照正确的顺序调用析构函数，这也是一种惯例
}
class  derive:public base{
public:
    virtual void printt(); // 派生类的virtual关键词可以省略，但显示的指出哪些是虚函数会更方便查看，不用省略
}
base &ba1=base();
base &ba2=derive();
ba1.printt(); // 调用的是base.printt()
ba2.printt(); // 调用的是derive.printt(),如果没有virtual的声明，那就是看本身引用的类型，而不是引用指向的类型，也就是调用base.printt(),指针也是如此
(1)当该类有虚函数时，则该类会有一个隐藏的地址成员，也就是虚函数指针，该指针指向该类的虚函数表，多个虚函数就往表里多加一个地址数据，派生类重写了虚函数，就在自己的虚函数表上更新原来基类的地址。虚函数表在编译时就已经建立好的，运行时不能再修改，所以其存在常量区(虚函数表指针自然是跟着对象，如果是new的对象那就在堆，如果是在函数内创建的对象，那就在栈)，所有的类对象共享一个虚函数表，不同类的虚函数指针不同，虚函数表自然也不同。
(2)要在派生类重新定义的类方法，应该在基类中声明为虚函数
(3)构造函数不能是虚函数，因为派生类的构造函数和基类的构造函数本身就没有继承关系，他们都有自己的构造函数
(4)如果你要将这个类用作基类，那请一定要提供虚析构函数，即使他不执行任何操作，因为当我们用基类指针接收派生类时，此时delete基类，则只会调动基类的析构函数，派生类新添加的数据内存则会遗漏，因为他们的析构函数没有继承关系，有了虚析构函数就会先调派生类析构函数，再调用基类析构函数。
(5)友元函数不能为虚函数，因为友元不是类成员，不具备继承关系
(6)虚函数的继承不是重载，而是在虚函数表中用新的函数地址覆盖了旧的函数地址，所以我们在重新定义时应尽量保持与基类虚函数原型完全相同，避免出现使用混乱。但是如果返回值是基类引用或者指针，那可以修改为指向派生类的引用或指针，c++允许返回类型随类型的变化而变化，这叫做“返回类型协变”。如果基类声明被重载了，那派生类应该重新定义所有版本，否则其他版本将被隐藏，导致派生类无法使用

// (6)在派生类中想使用基类的友元函数，但是友元函数又不能直接base::,此时可以将其强制转换为基类去使用base()

// （7）所有继承方式都是相对于该类要进行下一次派生时的派生类能不能使用该类成员而言的，不管你什么继承，基类的private你始终不能调用，基类的protected和public你始终可以调用，以private继承，那就是在第二次派生类中，基类所有成员都是privaate权限，二次派生类不能访问;以protected继承，那基类的public在二次派生类变为protected,private还是private;以public继承，那就是基类在二次派生类中什么都没变。

 // (8)使用using重新定义成员的继承方式（只能由低保密转向高保密性，原本是private的那不可能转protected或public,using只适用于继承，不适用于包含）
class der:private base{
    using base::pub; // 将pub修改为公有继承
}
```

// 5. 友元函数、友元类、友元成员函数（用于访问private成员，应对特例情况,后两者都是相对于两个类来说）
```cpp
class base;
class base2{
private:
    int pri2;
public:
    void printPri(base &ba);
    friend class base; // 友元类声明
}；

class base{
private:
    int pri;
public:
    friend void setpri(base &ba); // 友元函数，在类内声明，在类外定义
    friend void setpri2(base &ba){ba.pri=1;} // 友元函数，在类内声明和定义
    friend void base2::printPri(base &ba); // 友元成员函数声明，在另一个类的成员函数调用base的私有成员。
    void printPri2(base2 &ba2); // 友元类的函数声明可调用base2的私有以及保护成员。
}；
void base2::printPri(base &ba){cout<<ba.pri;} // 友元成员函数定义
void base::priPri2(base &ba2){cout<<ba2.pri2;} // 友元类的函数定义。
int main(){
    base ba;
    setprit(ba);
    setprit2(ba);
    base2 ba2;
    ba2.printPri(ba);
}

// 友元函数使用场景1：二元运算符重载,二元运算符就代表着要使用两个类，如果使用非成员函数，则两个类的私有数据我们都没法访问，虽然可以修改这两个类，使其添加可以获取私有数据的成员函数，这个方法对于其中一个类是标准类的情况下显然不适用(非成员函数的多元运算符重载至少要有一个用户自定义类，所以不存在两个类都是标准类的情况)，因为修改标准库是极其危险的行为。2.将标准类用作整体使用，不调用其私有数据，用自定义的类成员函数声明运算符重载函数，这样就能调自定义类的数据了，但是在自定义类的成员函数运算符重载要触发调用，则要将自定义的类写在左边操作数才能调用，例如MyClass<<cout,这就有点反人类了，所以我们可以用不是类成员函数但是又能调用类私有数据的的友元函数来进行二元运算符重载，既能调用数据又不用被成员函数运算符重载的位置属性给限制。
class cl{
private:
    int i;
public:
friend cl operator*(const cl &c1,int n);
friend ostream &operator<<(ostream &os, const cl &c);
};
cl operator*(const cl &c1,int n){
    cl c2;
       c2.i = c1.i * n; // 需要用友元函数才能访问私有数据c2.i
  return c2;
}
// 最经典的<<运算符重载(必须使用非成员运算符重载函数，因为形参cout总是在左侧，友元函数不算成员函数)
ostream &operator<<(ostream &os, const cl &c) {
  os << c.i;
  return os;
}
```
(1)无论友元函数是定义在类内或者类外都是一样的，他都不属于类，无法用类对象.调出来,要使用，直接函数名调用即可。  
(2)友元成员函数，先提前声明base类，再声明定义base2,以及其成员函数，而后将其成员函数在base中声明为友元函数，之后在类外定义即可（顺序不能乱）。
(3)友元函数是非成员函数访问类的数据,友元类是一个类要访问领一个类的数据，

// 6.类模版（常用于容器类，封装设计一些数据结构）
```cpp
template <class Type,typename T2=int> // 与参数一样，模版参数也可以有默认值
class cl{
public:
    void printt();
}

// 类限定符要改为cl<Type>::
vodi cl<Type>::printt(){}

// 模板类中的type需要显示的提供所需类型，而不能想模版函数那样能自行推断类型(模版函数printt<>(1)能自动判断类型，换句话说，就是<>里面必须要是类型名)
template <class T>
void funcPrint(T t){};

funcPrint(2); // 允许
// cl<2>; // 不允许
cl<int> c;

// 类模版的非类型参数（也叫表达式参数）
template<class T,int n>
class cl{
    T t;
public:
    void printt(){
        cout<<n;
        // cout<<&n;n++;// 这些都是无效的，不能修改参数的值，也不能使用其地址
        } 
}
int maain(){
    cl<int,1> c1;
    cl<int,1> c2; // 表达式参数每次声明都是独立的，而没有表达式参数的纯模版只会生成一个声明，速度会快些
}

// 模板类的默认类型参数
template<class T=int> class cl{}; // 与函数中的默认参数一样，默认值需要从右到左给起，实参传给形参是从左到右，如果最最右边没有默认值，那就说明最右的形参一定要传参，那将导致所有参数都得传，才能传到最右（因为中途不能传空参）。
class<> c1; // 使用时可省略，使用默认参数

// 具体化类模版（与类模版很相似，隐式、显示实例化和显示具体化统称为具体化）
cl<int> c1; // 隐式实例化
cl<int> *c1; // 这里只是指针类型，而没有生成具体的对象，所以并不会产生实例化，并不会创建对象
template class cl<int>; // 显示实例化，虽然没有对象，但编译器也将生成类声明（包括方法定义）
template <> class cl<int>{}; // 显示具体化，为某一些特定类型，重写类模版
template <class T1> class cl<T1，int>{}; //部分具体化，template后的<>内是不具体化的类型参数，剩下的就是要具体化的,如果有<T1,T2>那么T2就被具体化为int

// 模版的嵌套
template<T>
class cl{
    template<B>
    class cc{};
};

// 将模版用作参数
template <T>
class cl{};
template <template<T> class cl> 
class cc{ };

int main(){
    cc<cl> c2; // 只能传与cl有相同声明的模板类，更不能传cl创建的对象，因为cc的参数是模板类，而不是一个具体对象
}

// 模板类和友元
    // ......有点复杂，遇到具体案例再说

// 模版的别名,以及在模版中使用别名
using arrtype=std:array<T>; // 两者等效
typedef std::array<T> arrtype;

typedef typename student st; // 在模版里使用typedef最好用typename指明其是类型而不是变量。
```
(1)无论是类模版还是类成员函数模版，都不是类的定义，此时都不会给其分配内存。
(2)可以将所有常规类的技术应用于模板类
(3)可以递归使用模版:cl<cl<int,1>,2> c1;

// 7.类的构造函数与析构函数
```cpp
class cl{
private:
    int i;
    double d;
public:
    cl(); //即使不显示声明，c++也有默认的构造函数c1(){} ,调用默认构造函数用圆括号、空参函数;构造函数只在创建对象时执行一次，不可再次调用,构造函数没有返回值。
    cl(int n); // 带参数的构造函数，一旦声明有参的构造函数，并且没有显示的定义空参的构造函数（每个参数都有默认值的也算可以空参），那创建对象时就一定要带括号,如果有默认参数就可以不传参，没有默认参数则必须传参，形参名一定不能与类成员名相同，否则赋值给类成员就变成了i=i
    cl(int n=10,double b); // 使用默认参数初始化
    cl(int n,double b):i(n),d(b){} // 参数列表初始化
    ~cl(); // 析构函数，对象过期时调用,也可以主动多次调用
}
```
```cpp
cl c(); // 有括号时则是要调用有参数的构造函数，如果都无参，那调隐式默认构造函数，也就是什么都没做。
cl c2,c3,c4; // 无括号时，如果有显示默认构造函数，则调显示，没有则调隐式。
cl c1=cl(); // 创建了临时的的对象，然后将其赋值给c1,之后销毁临时对象（这个时间不确定,可能立即,可能等一会），这样的初始化方式可以让构造函数与析构函数都执行一遍,当构造函数是有参函数，即使是有默认值，那cl(1)，也要传参
cl c1={1}; // 列表初始化
 const cl c2(i); // const对象不允许调用其成员函数，因为不能保证成员函数对其数据的修改,但是可以调用析构函数，因为那时表示这些数据将过期。
```
(1)只要参数全部有默认值，那它就是默认构造函数，不能同时声明两个默认构造函数，例如：cl::cl();和cl::cl(int i=0);将造成二义性。

// 8.this指针,适用于类的成员函数，存储的是该对象的地址
```cpp
cl & printt(){return *this;}
```

// 9.对象数组
```cpp
cl cls[num]; // 这种创建方式只适用于默认构造函数(也就是无参构造函数，显示或隐式都可以)
cl cls2[num]={cl(1),cl(2)，cl(3)} // 列表初始化
```

// 10.作用域为类的常量
```cpp
class cl{
private:
    const int k=10; // 错误，k会初始化失败，为0值，因为类的声明只是描述了对象的形式，并没有创建对象，所以是不会分配内存的。另外的一种初始化方案是使用类构造函数的成员初始化列表，详情看第16点
    enum{months=12} ;// 方法一：可以利用枚举常量替代，这里的枚举不会创造类成员，也不属于类,但是他在类的作用域里。
    static const int mon=1; // 方法二：使用静态类成员常量，这将创建一个常量，与其他静态变量存储在一个区域，而不是存储在对象中，因此所有对象使用一个mon常量。不是const的static是不能在类声明中初始化。这种技术只适用于枚举和int类型，虽然说c++11放开了double常量,但是我测试了还是不行？
    static int month; // 不是const的静态类成员只能在类外初始化
}
int cl::month=1; // 类外初始化静态类成员

// 调用
int main(){
    cl::moths; // 优先使用
    cl c1; 
    c1.moths; // 了解
}
```

// 11.将一元构造函数用作自动类型转换函数（隐式转换），只支持从某种类型到类类型的转换，想要进行相反的转换请使用转换函数，见12点
```cpp
void cl::cl(int n){i=n;} // 一元构造函数用作转换函数
cl c=1; // 这是合法的，程序将使用构造函数cl(int i)创建临时对象赋值给c，如果c是已经初始化的有值的，那这个构建的临时对象将覆盖原先所有的成员数据
void cl::cl(int n,double b=1.2){i=n;} // 有默认值的构造函数也可以

// 但有时这种隐式转换也会带来bug和混乱(一般看看这种转换有没有实际意义，没有，就关掉)，所以c++体量explicit关键字，可以在需要的时候关闭这种自动转换
explicit cl(int n); // 在原型声明前加explicit就行
// 不过这只是关闭了隐式转换，我们还可以显示转换
cl c=cl(1); // 显示转换

cl c='a'; // 标准类型转将先把char换为int，在调用构造函数。

// 没有explicit限制时这种隐式转换发生场景罗列如下(以int参数的构造函数为例)：
cl c=1; // 1.将对象初始化为int值时

cl c;
c=1; // 2.将int值赋值给对象时

void printt(cl c){}
printt(1); // 3.将int值传授给接收对象参数的函数时

cl printt(){return 1;} // 4.返回值为对象的函数返回int值时

// 5.上述所有情况下，使用可隐式转换为int类型的内置类型时

// 与这些自动转换，默认调用的构造函数有着相似的是类中特殊的默认复制构造函数，详情请看13点
```

// 12.转换函数
```cpp
class cl{
    public:
operator int();
explicit operator double(); // c++11中转换函数同样能人工指定只能显示转换
}

cl::operator int() const{
return i;

int main(){
    cl c;
    int(c);
}
}

```
(1)转换函数一定要是类方法
(2)转换函数不能指定返回类型，其实中间的int就已经指定了，而且转换函数也是有返回值的，就是中间指定的类型
(3)转换函数不能有参数
(4)可以定义多个转换函数，但在使用时应注意其隐式转换的二义性，例如定义了int和double转换函数，用int接收可以自动判定为转换为int,但使用cout<<就会产生二义性了，此时可使用显示转换int(c)
(5)任何的便捷都是有代价的，请不要滥用隐式转换，以免造成混乱

// 13.特殊成员函数(如果没有显示定义就会自动产生，并在某种情况自动调用的函数)
```cpp
// 默认构造函数(无需过多介绍)
// 默认析构函数(无需过多介绍)

// 复制构造函数:将一个对象复制到一个新创建的对象（只是复制，没有改变数据，所以不要漏掉const）
cl::cl(const cl &c){*this.i=cl.i;} // 默认复制构造函数是按值传递，如果类中有new的指针数据成员，一定要显示定义复制构造函数(用strcpy函数进行深度复制)，不然将只复制指针，指针指向的值不会复制过去，静态数据成员不受影响，更不会创建副本，他们本来就不属于某个实例化的类对象，而是属于类本身，所有实例对象都共享一个。
cl c;
    // 何时触发？新建一个对象，并将其初始化为同类现有对象时，常规的，已经声明好的两个对象之间的赋值不会触发
    cl c2=c;
    cl c2=cl(c);
    cl c2(c);
    cl *c=new cl(c);

// 自定义类之间的赋值运算符重载成员函数：当我们使用赋值运算符去进行两个相同自定义类的复制时，如果我们没有显式重载赋值运算符，那它将默认是按值传递，与默认的复制构造函数一样有拷贝不完全的风险。解决方案也是当有指针数据时要记得显示重载赋值运算符。与复制构造函数不同的是，这里的重载赋值运算符函数要返回一个指向调用对象的引用，这样就能像S1=S2=S3这样连续赋值了；该函数要用this指针判断其传入的是不是它本身，本身赋值给本身，无效内存消耗，而且函数里一般都伴随有释放内存操作，这就很有可能删除对象内容；赋值前记得先清空本身，因为之前可能有残留数据。
cl& cl::operator=(const cl &c){*this.i=c.i;} // 与复制构造函数一样都是按值传递
    // 何时触发？已有的对象赋值给另一个已经声明的对象时
    cl c1;
    cl c2;
    c1 = c2;
    cl c3=c1; // 这种初始化的情形下，不一定会调用赋值运算符，大概率调用复制构造函数 

// 地址运算符
cl* cl::operator&(){return this;} 
    cl c;
    &c; // 与我们的基本类型一致
```

// 14.静态类成员函数
```cpp
class cl{
private:
    int i;
   static double b; // 有关静态；类成员的初始化与调用请看第10点
public:
    static void printt();
}

void printt(){
    // cout<<i; // 错误，静态类成员函数只能访问静态类成员
    cout<<b;
}
// call
int main(){
    cl::printt(); // 不能通过对象调用，甚至不能通过this指针调用
}
```

// 15.构造函数中使用new时的注意事项(第13点提及到一些)
```cpp
// 1.构造函数一定要向析构函数兼容，因为析构函数只有一个，如果析构函数是delete[],那所有构造函数都必须是new[]。空指针的话，所有删除方式都适配，所以可以随便用，在c++中空指针一般用nullptr

// 2.应该显示定义一个复制构造函数来复制数据，而不是由默认的复制构造函数只复制地址，具体定义看第13点

// 4.应当显示重载一个赋值运算符函数，原因与复制构造函数一样，要复制数据，而不是任由默认的赋值运算符函数去只复制地址，具体定义看13点

// 5.当使用了new的类作为其他类的数据成员时，那是不是也要为该类写复制构造函数和赋值运算符函数？答案是否定的，默认的追成员复制和赋值行为具有一定智能性，类中的数据成员显示定义了自己的复制构造函数，那就会调用显示的。
```

// 16.类构造函数的成员初始化列表
```cpp
// 该语法一般用于初始化常量、引用类型的类成员，因为他们必须在声明的时候才能初始化，但由于类内声明只是描述，没有给分配内存，所以没法在类内声明的时候进行初始化，那我们就在构建对象之前，也就是执行构造函数的函数体之前，初始化他们。
cl::cl(double d):b(d),i(2){}
```
(1)其他类型的数据成员也能这样初始化,静态的不行，因为根本无法在构造函数内访问，也不适于类。
(2)他们的初始化顺序与类声明中的顺序相同，与初始化器顺序无关。
(3)成员列表初始化只能用在构造函数上，其他成员函数无效。

// 17静态联编与动态联编(与4点地(5)小点的虚函数相关)
```cpp
// 与静态变量，动态变量相似，静态联编与动态联编就是一个在编译的时候确定好使用哪个函数代码块，也就是哪个方法，而动态联编就是运行时才决定使用哪个方法，举例：
void ba(base &b){b.printt();} // printt()是基类与派生类都有定义的虚函数
int main(){
    base bas;
    derive der;
    ba(bas); // 调用的是bas.printt();
    ba(der); // 调用的是der.printt();
}
// 所有被virtual修饰过的函数都会变成动态联编，有关静动态联编的特点以及差异，我们需要了解动态联编的工作原理(也是虚函数的原理)：
    // 其原理就是给每一个对象添加一个隐藏成员，其中保存了一个指向函数地址的数组指针，里面存的都是该对象的虚函数地址，这种数组称为虚函数表(vtbl)，也就是保存了指向虚函数表的指针
// 定义了虚函数就把地址加到表里,用的时候再按数组顺序取，所以总结动静联编特点如下：
    (1)每个对象都将增大，用于存储指向虚函数表地址的指针
    (2)每个类，编译器都要创建一个虚函数表(数组)
    (3)对于每个函数调用都需要一些额外操作，例如表中查地址
    // 所以总结起来就是非虚函数效率高，所需空间小，但是不具备动态联编功能
// 虚函数的一些注意事项
    (1)构造函数不能是虚函数，派生类并不继承基类的构造函数，他们有各自的构造函数，只是构造派生类之前要先调用基类构造函数，有了基础数据才能再此基础上派生。
    (2)只要该类用作基类，那该类的析构函数必须为虚函数，来保证释放时析构函数的正确调用顺序，而且就算不用做基类，虚析构函数也不会导致任何问题，只是效率会低点，仅此而已
    (3)友元不能是虚函数，他本来就不属于类
    (4)基类与派生类的虚函数原型一定是完全相同的，参数特征标相同，否则派生类的函数将会覆盖掉基类函数，导致基类函数无效，当然返回值如果是基类引用或指针，那派生类这边可以改为派生类的引用或指针
    (5)如果基类声明被重载了，那一定要所有重载版本都要virtual定义一遍

```

// 18.抽像基类（ABC，与第4点的继承知识相关）
```cpp
// 抽象基类：当基类A和B具有继承关系，而B又用不上A的大多数A成员，继承吧又会造成B类臃肿，不如直接定义B类来的方便，但是直接定义又丢弃了他们两之间确实存在的继承关系。此时就可以取他们之间的共同数据成员与函数来构建抽象基类，让A和B都继承抽象基类，这样就既能建立is-a关系，又不臃肿（例如圆属于椭圆，可以从椭圆里派生出圆，但是圆只需要一个半径就能描述体积面积，不需要椭圆的半长轴、短半轴这些乱七八糟的数据成员）
class cl{
public:
    void printt() =0; // 函数声明的结尾处为“=0”的叫做纯虚函数，纯虚函数是没有函数体的，派生类必须重写纯虚函数。
}
```
(1)只要包含了纯虚函数，那就只能用作基类，而且不能创建对象，纯虚函数可以看做是一种特殊的虚函数，他必须要重写。


// 19.类中使用动态内存(与第13点相关联)
```cpp
class cl{
private:
    char *ch;// 使用new的类一定要显示定义：析构函数、复制构造函数、重载运算符函数(这三个以及友元都是不能继承的)，具体原因看13点
}
class clDer:public cl{
private:
    char ch[];// 不使用new的派生类不需要显示定义上面那些
}
class clDer2:public cl{
private:
    char *ch2;// 使用new的派生类需要显示定义上面那些
}
```

// 20.has-a(包含)关系的实现(与3(4)的内容有关联)
```cpp
// 一个类包含另一个类对象
class score{
private:
    double sum;
    double math;
void printt();
public:
    score(double su=0.0,double ma=0.0):sum(su),math(ma){}
    ~score(){}
}
class student{
private:
    score sc;
public:
    student(double su=0.0,double ma=0.0):sc(su,ma){sc.printt();} // 注意，初始化用的变量名sc,调用其方法也用sc
    ~student(){}
}

// 使用private继承(特意添加多重继承MI的知识点)
class student:private score,private valarry<double>{ // 每一个都要有权限关键字修饰，不然就是默认private
public:
typedef valarry<double> dbArr;
    student(double n=0.0,double m=0.0):score(n),dbArr(m){} // 这里使用的就是类型名了，而不是变量名,调用方法也是
    ~student(){}
    void stuPrintt(){
        score::printt();
        score(*this); // 要访问基类对象需要使用强制转换，转成基类，即使是公有继承也要显示转换，因为这是个多重继承，编译器不知道转换围为哪个基类
    }
}；
```
(1)两者都可以实现has-a关系，但是一般c++程序都偏向于使用包含，因为它相对私有继承来说更便于理解，多重继承也会带来诸多问题，例如包含同名方法的独立基类或共享祖先的独立基类等等，不过有些情况下必须使用私有继承：如果新类需要访问原有类的保护成员或需要重新定义虚函数，此时必须要用私有继承

// 21.多重继承，例如手机，就可以继承通讯设备、拍摄设备等多个类。其中的问题可不少，具体示例如下：
```cpp
// 正常继承来说没啥问题，只需要注意两个基类有方法名称冲突的情况下，在派生类成员函数中使用类限定符(例如：base1::function)来区分即可
class Base{void setVal(){}};
class Base1{void setVal(){}};
class Der1:public Base,public Base1{
    public:
    Der1():Base(),Base1(){}
    void getVal(){
        Base::setVal(); // 
    }
};
// 当其通过多条途径最终继承的类都是同一个基类时将会引发系列问题:
class Base{};
class Der1:public Base{};
class Der2:public Base{};
class Der:public Der1,public Der2{};
Der d;
// Base *ba=&d // 产生二义性，d中有两个Base基类，是用Der1的还是Der2的？这个问题我们可以用类型转换解决：
Base *ba=(Der1 *)&d // 显示转换为Der1指针，但是治标不治本，一个类包含两个相同的对象，再绝大多数情况下是不合理的，所以c++引入多重重载时，还引入了新技术-虚基类，这个名字听起来与虚函数类似，但是确没有啥必然联系，只是官方不想引入新的关键词，增加使用者的负担，算是virtual的重载，注意，虚基类要付出额外的计算来实现的，而且也更麻烦，如果不是多个基类的基类是同一个，那不要去用它，例子如下：
class Der1:public virtual Base{};
class Der2:virtual public Base{}; // virtual和public的顺序无关紧要,此时Der1和Der2共享一个Base副本。
// 一旦使用虚基类则要跟着变动许多东西，第一个就是在派生类的构造函数中，禁止信息通过中间类自动传递给基类，因为一旦同意，那将有多条路径传进来，基类不知道用哪一个，它就只能去调自己默认的构造函数。如果你不想这样的事情发生，那你要显示调用基类的构造函数，示例如下：
class Der:public Der1,public Der2{
    // Der(const Base &b):Der1(b),Der2(b){} // 假设Der1和Der2都定义了接收Base参数的构造函数，那这样两个途径传过去是不允许的，基类只会调用默认构造函数(一般是没有形参的那个构造函数)
    Der(const Base &b):Base(b),Der1(b),Der2(b){} // 显式的调用基类构造函数，注意，这对非虚基类来说是非法的
};

```

// 22.移动构造函数:对于右值引用所造成的匿名临时变量的内存浪费所提供的解决方案，我们可以不删除这个匿名临时变量，而是直接将这个临时变量与接收者相关联，这种方法被称之为移动语义，但是他的原理并不是移动原始数据，而恰恰是为了不移动原始数据，只是修改了记录。一般都可以定义两个构造函数，一个是左值引用形参(复制构造函数)，一个是右值引用形参(移动构造函数)。注意，移动构造函数一定不能是const，因为他要修改实参。
```cpp
class cl {
    int * i;
public:
    cl(cl &c){i=c.i;}
    cl(cl &&c1){i=c1.i;
        cl.i=nullptr;  // 将原本的指针清空，不清空等会这个临时对象触发析构函数就会把他给释放掉。
    }
    cl operator+(const cl &c){......}
}
cl returnCl(){cl c1;return c1;}
cl c1;
cl c2(c1); // 调用复制构造函数
cl c3(c1+c2); // 调用移动构造函数
``` 