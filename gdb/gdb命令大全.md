## <b>GDB</b>
### 启动gdb以及加载运行程序
```cpp
gdb // 进入gdb
gdb ./executable_file // 进入gdb同时加载运行程序
gdb -p process_id // 根据pid将gdb挂载到已经运行的进程当中，注意，gdb的介入会将正在运行的程序暂停，gdb退出后又恢复运转。一般配合对应shell终端的查询进程命令使用，例如cmd:tasklist | find  "进程名"
file ./executable_file // 在进入gdb后再加载运行文件
attach process_id // 进入gdb后，挂载已经运行的进程
gdb ./executable_file core_file // 挂载运行程序的同时指定核心文件(core file是在程序异常终止时,比如段错误、浮点异常等,由操作系统生成的一种文件。它包含了程序在异常终止时的内存映像，包括程序执行时的堆栈、寄存器状态、内存分配情况等信息)
r // run 运行程序
```
(1)注意，在使用gcc编译时记得带上-g参数，不然运行程序不会记录代码行数这些辅助调试信息。
### 运行程序前的可可执行操作
``` cpp
// 传参设置
set args 参数1 参数2 // 如果参数有空格等特殊符号，记得用双引号引起来，如果多次set args，那么新的会覆盖旧的
unset args // 清空参数设置

// 断点(有段断点程序才会停止，才能使用逐行运行等分布操作)
    // 创建
b 行数 // 行断点
b 函数名 // 函数断点
b 地址 // 地址断点
watch x // 监视点，只要x变量发生了变化，那程序就暂停
b ...... if 判断条件 // 条件断点
b ...... temp // 临时断点，run一次之后就会自动删除，第二次run将b
b ...... -label "标记" // 给断点打标记，之后删除以及查询都可用它代替编号，标记不能修改，要么就直接删除该断点重新打
    // 修改

    // 查看
info breakpoints // 罗列出当前的所有断点信息
    // 删除
delete // 不带任何参数则会删除所有断点
delete 断点数字编号  // 根据编号删除断点
delete 1-5 // 根据编号大范围删除断点
```

### 断点调试中可以执行的操作
``` cpp
p 变量/表达式 // 打印进程里的变量或者表达式的值
n // net 下一行,不会计入函数内部
s // step 下一步，会进入函数内部，只有自定义的代码才能进去，比如说里面有c++内置的printf()函数，或者其他第三方库的函数，那这个函数是进不去的
c // continue 跳过，直接到下一个断点
set var name=value // 设置变量的值
bt // 查看当前线程的函数调用栈，#0代表此当前执行点所在的调用函数#1是#0的上一层函数。不是说罗列出所有已经调用过的函数，而是当前函数的一个嵌套，如果函数A里调用了函数B，而此时正运行到B函数里中断了，那此时bt就显示A是#1，B是#0，遵循先进后出的原则
```
### 